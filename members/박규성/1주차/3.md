# 1. 문제 파악

## 1-1. 주어진 정보

### 인자

1. order : 컨테이너 벨트에 실어야 하는 상자의 순서

### 리턴값

: 실을 수 있는 최대 상자의 수

### 전제 조건

1. 택배상자의 크기는 모두 같다.
2. 1번 상자부터 n번 상자까지 번호가 증가하는 순서대로 일렬로 놓여 영재에게 전달된다.
3. 이 택배상자를 택배 기사님이 미리 알려준 순서에 맞게 실어야 한다.
4. 맨 앞의 상자만 뺄 수 있다.
5. 기사님이 원하는 순서대로 싣지 못한다면, 더이상 상자를 싣지 않는다.

### 우려 사항

1. order의 길이는 최대 100만으로, O(N)에서 끝내야 한다.

### 예시 1.

1. 1,2,3 상자를 보조 컨테이너에 보관한다.
2. 4 상자를 트럭에 싣는다.
3. 3 상자를 보조 컨테이너에서 꺼내 트럭에 싣는다.
4. 1상자를 꺼내야 하는데, 2가 가로막고 있기에 불가능하다.

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/131704

# 2. 내 풀이

## 2-1. 알고리즘

Stack을 활용한 알고리즘

## 2-2. 시간복잡도

O(N) (N은 order의 길이, 최대 100만)

## 2-3. 1차 풀이 (시간 초과, 30점)

```jsx
function solution(order) {
  const containerBelt = Array.from(new Array(order.length), (_, i) => i + 1);
  const tempContainerBelt = []; // Stack
  let i = 0;
  while (1) {
    const currentOrder = order[i];
    while (1) {
      if (currentOrder === containerBelt.at(0)) {
        containerBelt.shift();
        break;
      }
      if (currentOrder === tempContainerBelt.at(-1)) {
        tempContainerBelt.pop();
        break;
      }
      if (currentOrder < tempContainerBelt.at(-1)) return i;
      tempContainerBelt.push(containerBelt.shift());
    }
    i++;
    if (i === order.length) return i;
  }
  return answer;
}
```

- 각 경우마다 pop,push를 해서 그런 지, 시간 초과에 걸렸다.
- ⇒ 대처방안 : pop, push를 하지 않고, index로 현재 위치를 관리한다.

## 2-4. 2차 풀이 (최종)

```jsx
function solution(order) {
  const tempContainerBelt = []; // Stack
  let i = 0;
  let containerBeltNum = 1;
  while (1) {
    const currentOrder = order[i];
    while (1) {
      if (currentOrder === containerBeltNum) {
        // 컨테이너 벨트의 가장 앞에 있다면
        containerBeltNum++;
        break;
      }
      if (currentOrder === tempContainerBelt.at(-1)) {
        // 임시 컨테이너 벨트의 가장 앞에 있다면
        tempContainerBelt.pop();
        break;
      }
      if (currentOrder < containerBeltNum) return i;
      tempContainerBelt.push(containerBeltNum++);
    }
    i++;
    if (i === order.length) return i;
  }
}
```

기존 배열 자료구조로 관리하던, 컨테이너 벨트를 숫자로 관리하니 시간 초과가 해결이 되었다.

배열 자료구조를 이용하여 스택으로 관리하던 임시 컨테이너 벨트는 어떤 식으로 수정해야 시간 초과에서 벗어날 수 있을까..고민을 잠시 했지만, 다행이도 이를 수정하지 않아도 해결이 되었다.

1. 컨테이너 벨트는 숫자로 관리한다. 1,2,3..1씩 증가한다.

   ```jsx
   let containerBeltNum = 1;
   ```

2. 컨테이너 벨트의 현재 상자가 order에서 요구하는 현재 상자가 아니라면, 임시 컨테이너 벨트에 담는다. 임시 컨테이너 벨트는 가장 최근에 담긴 것을 가장 먼저 빼내야 하기에, LIFO 구조인 스택 방식을 채택했다. JS에서 스택은 push & pop을 이용하면 된다.

   ```jsx
   const tempContainerBelt = []; // Stack
   ```

3. order의 몇 번째까지 완료했는지 체크하기 위해 i로 값을 관리하였다. 처음에는 물론 0이다. 지금 돌이켜보면 i보다는 orderCnt같은 네이밍을 했으면 더 직관적이었을 것이라는 생각이 든다.

   ```jsx
   let i = 0;
   ```

4. whil문으로 무한 반복한다. 종료 조건은 order의 맨 끝까지 탐색하거나, 나머지 하나는 내부 while문에서 거르게 된다.

   ```jsx
   while (1) {
     const currentOrder = order[i];
     while (1) {
       // ..
     }
     i++;
     if (i === order.length) return i;
   }
   ```

   이중 while문이다. 바깥 while문은 하나의 order를 순회하는 것이다. 그래서, while문이 끝나면 i++를 한다.

   이제 내부 while문을 알아보자.

   ```jsx
   while (1) {
     if (currentOrder === containerBeltNum) {
       // 컨테이너 벨트의 가장 앞에 있다면
       containerBeltNum++;
       break;
     }
     if (currentOrder === tempContainerBelt.at(-1)) {
       // 임시 컨테이너 벨트의 가장 앞에 있다면
       tempContainerBelt.pop();
       break;
     }
     if (currentOrder < containerBeltNum) return i;
     tempContainerBelt.push(containerBeltNum++);
   }
   ```

   1. 컨테이너 벨트의 가장 바깥요소(containerBeltNum)와 현재 상자를 체크하고, 임시 컨테이너 벨트의 가장 바깥요소(tempContainerBelt.at(-1))와 현재 상자를 체크한다.

      ```jsx
      if(currentOrder === containerBeltNum){ // 컨테이너 벨트의 가장 앞에 있다면
          containerBeltNum++;
          break;
      }
      if(currentOrder === tempContainerBelt.at(-1)){ // 임시 컨테이너 벨트의 가장 앞에 있다면
          tempContainerBelt.pop();
          break;
      }
      ```

   2. 이 둘에도 곂치지 않았는데, 현재 상자의 숫자가 컨테이너 벨트의 가장 바깥요소보다 크기가 작다면 종료한다. while문을 종료(break)하는 것이 아니라, return을 함으로써 전역 함수 solution 자체를 종료한다.

      ```jsx
      if (currentOrder < containerBeltNum) return i;
      ```

      현재 상자의 숫자가 컨테이너 벨트의 가장 바깥요소보다 크기가 작다는 것은, 더 이상 일치하는 상자를 찾을 수 없다는 것을 의미한다. 왜냐하면, 컨테이너에 앞으로 올 숫자들은 현재 컨테이너의 바깥의 숫자보다 더 크기 떄문에, 앞으로도 일치할 수 없다. 또한, 위의 임시 컨테이너의 가장 바깥 요소와 체크할 때도 해당하지 않았기 때문에 임시 컨테이너 또한 움직일 수 없다.

   3. 1,2번에 해당하지 않았다면, 즉 컨테이너 벨트와 임시 컨테이너 벨트의 가장 바깥에서 현재 상자와 일치하는 숫자를 찾지 못했고, 현재 상자가 컨테이너의 가장 바깥 상자보다 크기가 크다면 다음 컨테이너벨트를 진행한다.

      ```jsx
      tempContainerBelt.push(containerBeltNum++);
      ```

      다음 컨테이너 벨트를 진행한다는 말은, 임시 컨테이너 벨트에 현재 컨테이너 벨트의 바깥 요소를 삽입하고(push), 현재 컨테이너벨트의 숫자를 1을 더하는 것(++)을 의미한다.

## Claude의 피드백

1. 변수명 : i보다는 orderIndex, completedOrders가 더 명확한 이름
2. 주석을 통한 각 부분의 역할 설명 굿
3. 배열 대신 숫자를 사용해 containerBeltNum으로 관리하는 것은 좋은 최적화
   - 하지만, Set를 사용하여 더 최적화할 수도(?)

## Claude의 리팩토링 후 코드

```jsx
function solution(order) {
  const tempStack = [];
  let containerNum = 1;
  let completedOrders = 0;

  for (const box of order) {
    while (containerNum <= box) {
      if (containerNum < box) {
        tempStack.push(containerNum);
      }
      containerNum++;
    }

    if (tempStack[tempStack.length - 1] === box) {
      tempStack.pop();
      completedOrders++;
    } else if (containerNum - 1 === box) {
      completedOrders++;
    } else {
      break;
    }
  }

  return completedOrders;
}
```

1. i → containerNum으로 직관적인 네이밍
2. 내부 while문에서는 containerNum < box만 체크한다. 내부 while문을 종료한 후, 컨테이너 벨트와 임시 컨테이너 벨트의 가장 바깥요소와 체크한다.
   - 이렇게도 할 수 있겠구나 이해는 가고, if문이 더 줄은 것은 효율성 면에서는 더 좋은 풀이라는 생각이 들지만, 더 직관적이지는 않다는 생각이 든다.

## 이전의 내 풀이와 비교

> [택배상자](https://www.notion.so/25dc1aebe5a748f7a97fa5cb99438953?pvs=21) (2024. 1. 21. 7개월 전)
>
> - Code
>   ```jsx
>   function solution(order) {
>     var answer = 0;
>     const orderLength = order.length;
>     const assistContainer = [];
>     let cnt = 0;
>     let nowI = 1;
>     let i = 0;
>     while (1) {
>       let nowOrder = order[i];
>       if (nowOrder === assistContainer.at(-1)) {
>         assistContainer.pop();
>         cnt++;
>         i++;
>         continue;
>       } else {
>         if (nowI > orderLength) break;
>         assistContainer.push(nowI++);
>       }
>       if (nowI > orderLength) break;
>     }
>
>     return answer;
>   }
>   ```

당시에는 내가 처음에 푼 풀이처럼 배열로 관리하다가 시간초과에 걸려서 포기한 듯하다. 당시에, 다른 시도는 안해보고 정말 빨리 포기했었네 ..

이번에는 오로지 내 힘으로 풀어내어 뿌듯하다. ㅎ
