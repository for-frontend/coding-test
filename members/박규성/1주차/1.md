# 1. 문제 파악

## 1-1. 주어진 정보

### 인자

1. maps. 최대 100
   1. S : 시작 지점
   2. E : 출구
   3. L : 레버
   4. O : 통로
   5. X : 벽
   - 시작 지점, 출구, 레버는 항상 다른 곳에 존재, 1개 씩만 존재

### 리턴값

미로를 탈출하는데 필요한 최소 거리. 만약 불가능하다면 -1 리턴

### 전제 조건

1. 1\*1크기의 칸들로 이루어진 직삭각형 격자 형태의 미로에서 탈출
2. 각 칸은 통로/벽. 통로로만 이동 가능
3. 레버가 존재 -> 빠져나갈 수 있다.
4. 출발 지점 -> 레버 -> 빠져나가는 문
5. 한 칸 이동하는데 1초

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/159993

# 2. 내 풀이

## 2-1. 알고리즘

BFS

## 2-2. 시간복잡도

O(N _ M) (N과 M은 세로와 가로의 크기, 최대 100 _ 100)

## 2-3. 풀이

```jsx
function solution(maps) {
  const START_POINT = "S";
  const END_POINT = "E";
  const LEVER_POINT = "L";

  const PASSAGE = "O";
  const WALL = "X";

  const DIRECTIOIN_LIST = [
    [0, 1],
    [0, -1],
    [1, 0],
    [-1, 0],
  ];

  const findIndexOfStringArray = (stringArray, item) => {
    const indexY = stringArray.findIndex((it) => it.includes(item));
    const indexX = stringArray.at(indexY).indexOf(item);
    if (indexY === undefined || indexX === undefined) return -1;
    return [indexY, indexX];
  };
  const startPosition = findIndexOfStringArray(maps, START_POINT);
  const leverPosition = findIndexOfStringArray(maps, LEVER_POINT);

  maps = maps.map((map) => map.split(""));

  const isArrayHaveIndex = (arr, indexY, indexX) =>
    0 <= indexY && indexY < arr.length && 0 <= indexX && indexX < arr[0].length;

  function findPoint(startPosition, endPoint) {
    const newMaps = Array.from(
      new Array(maps.length),
      () => new Array(maps[0].length)
    );
    maps.forEach((map, indexY) => {
      map.forEach((it, indexX) => {
        newMaps[indexY][indexX] = maps[indexY][indexX];
      });
    });
    let cnt = 0;
    let queue = [startPosition];
    while (1) {
      cnt++;
      const queueTmp = [];
      for (const [positionY, positionX] of queue) {
        for (const [directionY, directionX] of DIRECTIOIN_LIST) {
          const afterPositionY = positionY + directionY;
          const afterPositionX = positionX + directionX;
          if (
            isArrayHaveIndex(newMaps, afterPositionY, afterPositionX) &&
            newMaps[afterPositionY][afterPositionX] !== WALL
          ) {
            if (newMaps[afterPositionY][afterPositionX] === endPoint)
              return cnt;

            newMaps[afterPositionY][afterPositionX] = WALL;
            queueTmp.push([afterPositionY, afterPositionX]);
          }
        }
      }
      if (queueTmp.length === 0) return -1; // 더 이상 이동할 수 있는 곳이 없다면
      queue = queueTmp;
    }
  }

  const leverCnt = findPoint(startPosition, LEVER_POINT);
  const endCnt = findPoint(leverPosition, END_POINT);
  if (leverCnt === -1 || endCnt === -1) return -1;
  return leverCnt + endCnt;
}
```

BFS로 두 번 탐색하면 되는 문제이다.

첫 번째 탐색은 S(시작지점)에서 시작하여 L(레버지점)에 도달하고, 그 다음은 L에서 E(목적지 지점)에 도달하면 된다. 경로가 곂쳐도 되기에 각각은 독립된 케이스이기에, maps배열을 변형하였다면 다음 케이스를 수행할 때는 maps배열을 원상태로 되돌려야한다.

## 2-4. 실수 Point

1. at()으로 index값 존재하는지 체크하려했으나, -1도 값을 리턴한다는 걸 깜빡했다.

## 2-5. 아쉬움 Point

1. 복사가 잘 안되었다. 참조만을 복사하는 얕은 복사가 계속 되어서, 명령형으로 깊은 복사를 작성하였다.

   ```tsx
   const newMaps = Array.from(
     new Array(maps.length),
     () => new Array(maps[0].length)
   );
   maps.forEach((map, indexY) => {
     map.forEach((it, indexX) => {
       newMaps[indexY][indexX] = maps[indexY][indexX];
     });
   });
   ```

   더 가독성 좋고 선언적인 코드를 작성할 수 있을 듯한데, 배열 복사에 대해 더 공부해야겠다.

2. 특정 원소를 찾는 과정도 상당히 아쉬웠다.

   ```tsx
   const findIndexOfStringArray = (stringArray, item) => {
     const indexY = stringArray.findIndex((it) => it.includes(item));
     const indexX = stringArray.at(indexY).indexOf(item);
     if (indexY === undefined || indexX === undefined) return -1;
     return [indexY, indexX];
   };
   ```

   ‘문자열로 이루어진 1차원 배열’에서밖에 찾지 못하는데, 조금 더 포괄적인 함수로 만들었으면 좋았을텐데라는 생각이 들었다.

# 리팩토링

1. 각 Point를 객체로 그룹화하여 가독성을 높인다.

   ```tsx
   const POINTS = {
     START: "S",
     END: "E",
     LEVER: "L",
     PASSAGE: "O",
     WALL: "X",
   };
   ```

2. findPosition함수로 위치를 찾는 함수를 조금 더 깔끔하게 수정한다.

   ```tsx
   const findPosition = (char) => {
     for (let y = 0; y < maps.length; y++) {
       const x = maps[y].indexOf(char);
       if (x !== -1) return [y, x];
     }
     return null;
   };
   ```

3. 좌표가 존재하는지 체크하는 함수를 isValidPosition으로 조금 더 직관적으로 네이밍을 수정한다.

   ```tsx
   const isValidPosition = (y, x) =>
     y >= 0 && y < maps.length && x >= 0 && x < maps[0].length;
   ```

4. 방문했는지에 대한 2차원 배열을 만든다.

   ```tsx
   const visited = maps.map((row) => row.split("").map(() => false));
   visited[start[0]][start[1]] = true;
   ```

   mas.map을 이용하여 1차원 배열들을 가져오고, map을 한 번 더 사용하여 각 요소들을 false로 설정한다.

   그리고 방문하면, true로 값을 변경한다.

5. queue에 position과 distance 프로퍼티를 객체로 저장함으로써 조금 더 직관적으로 사용할 수 있도록한다.

   ```tsx
   const queue = [{ position: start, distance: 0 }];
   ```

6. bfs내부에서, tmp배열을 만들지 않고, 하나의 배열을 이용한다. 대신, queue의 특성에 맞게 shift를 하여 가장 앞의 요소부터 빼온다. while문의 종료 조건은 queue배열이 비었을 때(-1 리턴), 그리고 도착지점에 도착했을 때(distance 리턴)이다.

   ```tsx
   while (queue.length > 0) {
     const {
       position: [y, x],
       distance,
     } = queue.shift();
     if (maps[y][x] === end) return distance;
     // ..
   }
   ```

## 리팩토링 후 코드

```tsx
const solution = (maps) => {
  const POINTS = {
    START: "S",
    END: "E",
    LEVER: "L",
    PASSAGE: "O",
    WALL: "X",
  };

  const DIRECTIONS = [
    [0, 1],
    [0, -1],
    [1, 0],
    [-1, 0],
  ];

  const findPosition = (char) => {
    for (let y = 0; y < maps.length; y++) {
      const x = maps[y].indexOf(char);
      if (x !== -1) return [y, x];
    }
    return null;
  };

  const isValidPosition = (y, x) =>
    y >= 0 && y < maps.length && x >= 0 && x < maps[0].length;

  const bfs = (start, end) => {
    const queue = [{ position: start, distance: 0 }];
    const visited = maps.map((row) => row.split("").map(() => false));
    visited[start[0]][start[1]] = true;

    while (queue.length > 0) {
      const {
        position: [y, x],
        distance,
      } = queue.shift();

      if (maps[y][x] === end) return distance;

      for (const [dy, dx] of DIRECTIONS) {
        const newY = y + dy,
          newX = x + dx;
        if (
          isValidPosition(newY, newX) &&
          !visited[newY][newX] &&
          maps[newY][newX] !== POINTS.WALL
        ) {
          visited[newY][newX] = true;
          queue.push({ position: [newY, newX], distance: distance + 1 });
        }
      }
    }

    return -1;
  };

  const startPosition = findPosition(POINTS.START);
  const leverPosition = findPosition(POINTS.LEVER);

  if (!startPosition || !leverPosition) return -1;

  const leverDistance = bfs(startPosition, POINTS.LEVER);
  if (leverDistance === -1) return -1;

  const endDistance = bfs(leverPosition, POINTS.END);
  if (endDistance === -1) return -1;

  return leverDistance + endDistance;
};
```

### 리팩토링 points

1. POINTS객체로 관리하여, 각 POINT의 이름을 꼭 기억하지 않아도 된다.
2. findPosition 함수에서 for문으로 순회하여, 모든 값을 순회하지 않고 필요한 값에서 멈추도록 한다.
3. bfs문에서 tempQueue를 만들지 않고, queue.shift를 통해 가장 앞선 요소부터 순회하도록 한다. 또한, distance값도 queue에 담아서, 리턴할 때 사용한다.
4. queue에는 position과 distance를 프로퍼티로 가지는 객체를 담는다.
