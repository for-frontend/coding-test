# 1. 문제 파악

## 1-1. 주어진 정보

### 인자

1. n : 처음 병사 수 (<= 10억)
2. k : 사용 가능한 무적권 횟수 (<= 50만)
3. enemy : 매 라운드마다 공격해오는 적의 수 (<=100만)

### 리턴값

: 몇 라운드까지 막을 수 있는가

### 전제 조건

1. 적의 수만큼 병사를 소모한다.
2. 무적권을 사용하면, 병사의 소모없이 공격을 막을 수 있따.

### 우려 사항

1. n은 최대 10억이다.
2. 적의 수는 최대 100만이다. O(N)에서 끝내야 한다.

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/142085?language=javascript#

# 2. 내 풀이

풀이 1 : 투 포인터 (log N)
left를 0, right를 enemy의 끝부터 시작한다. right는 최대 100만이다.
절반씩 범위를 좁히며, 현재 가능한 경우인지 체크한다.
수가 많은 순으로 정렬(O(log N)) -> 앞에서부터 k개 제외하여 합 구하기

## 2-1. 알고리즘

: 투포인터

## 2-2. 시간복잡도

## 2-3. 풀이

```jsx
function solution(n, k, enemy) {
  const getSumOfEnemy = (index) => {
    const slicedEnemy = enemy.slice(0, index + 1);
    //         내림차순 정렬하여, 큰 수가 앞에 오도록 한다.
    slicedEnemy.sort((a, b) => b - a);
    //         앞에서부터 k개는 무시한다. (무적권을 사용한다)
    const sum = slicedEnemy.slice(k).reduce((prev, cur) => prev + cur, 0);
    return sum;
  };

  let left = 0,
    right = enemy.length - 1;

  while (1) {
    let mid = Math.round((left + right) / 2);

    if (left >= right) return mid + 1;

    const sum = getSumOfEnemy(mid);
    if (sum < n) left = mid;
    if (sum === n) return mid + 1;
    if (sum > n) right = mid - 1;
  }
  return answer;
}
```

모든 경우를 앞에서부터 순차적으로 계산하는 평화로운 풀이를 처음에는 생각했으나, 제한사항에서 값들의 최대값을 보고 생각이 싹 바뀌었다. n은 최대 10억. 이는 크게 상관이 없지만 enemy길이가 최대 100만이다. 시간 복잡도 O(N^2)은 안된다는 말이다.

O(logN)으로 끝낼 수 있는 투포인터를 떠올렸다. 투포인터는 절반씩 범위를 좁혀나가기에 시간 복잡도를 줄일 수 있는 매우 획기적인 방법이다.

1. 투포인터답게 왼쪽과 오른쪽을 잡고 시작한다.

   ```tsx
   let left = 0,
     right = enemy.length - 1;
   ```

2. while문으로 무한반복을 시작한다.

   ```tsx
   while (1) {
     let mid = Math.round((left + right) / 2);

     if (left >= right) return mid + 1;

     const sum = getSumOfEnemy(mid);
     if (sum < n) left = mid;
     if (sum === n) return mid + 1;
     if (sum > n) right = mid - 1;
   }
   ```

   1. while 반복문의 종료조건은 left가 right와 같거나, 클 때이다.

      ```tsx
      if (left >= right) return mid + 1;
      ```

      left가 원래 right보다 작은 값인데, 같아졌다는 말은, 이제 더 탐색할 값이 없다는 말을 의미한다.

   2. mid는 left와 right의 중앙값이다.

      반올림 메서드인 Math.round를 사용했다.

      올림인 Math.ceil 또한 잘 풀리는데 Math.floor는 풀리지 않는다. 원인은 조금 더 고민을 해보아야겠따.

      <aside>
      <img src="/icons/light-bulb_blue.svg" alt="/icons/light-bulb_blue.svg" width="40px" /> 올림, 반올림은 잘 풀리지만 내림은 안 풀리는 이유

      내림을 사용하면 left와 right가 같아질 때 무한 루프에 빠질 수 있다.

      </aside>

   3. 이제, 현재 값(mid)을 기준으로 합산을 구한다.

      ```tsx
      const sum = getSumOfEnemy(mid);
      ```

      ```tsx
      const getSumOfEnemy = (index) => {
        const slicedEnemy = enemy.slice(0, index + 1);
        //         내림차순 정렬하여, 큰 수가 앞에 오도록 한다.
        slicedEnemy.sort((a, b) => b - a);
        //         앞에서부터 k개는 무시한다. (무적권을 사용한다)
        const sum = slicedEnemy.slice(k).reduce((prev, cur) => prev + cur, 0);
        return sum;
      };
      ```

      getSumOfEnemy함수는, 인자로 넘겨준 index값까지의 적 수를 계산하는 것이다.

      적 수는, 무적권 사용을 제외한 라운드의 적들의 합산을 의미한다. 내림차순 정렬을 한 후 앞에서부터 무적권을 사용하는 방식으로 계산하였다.

   4. 합산이 구해야할 값보다 작다면 left를 mid로, 크다면 right를 mid-1로, 동일하다면 while문을 종료한다.

3. 리턴값은 mid+1이다. 왜냐하면, 우리가 다루고 있던 값들은 index이고, 우리가 구해야할 것은 실제 라운드 수이기때문이다. 실제 라운드는 index + 1이다. (index = 0 : 1라운드, index = 1 : 2라운드 ..)

## 2-4. Claude의 리뷰

1. while(1) 대신 while(left≤right)가 더 명확할 수 있다.
2. Math.round()대신 Math.floor()를 사용하는 것이 더 일반적이다. 항상 왼쪽으로 치우처진 중앙값을 제공한다.
3. if(sum<n) left = mid + 1로 변경하는 것이 좋다. 현재 구현에서는 left가 mid와 같은 경우 무한 루프에 빠질 수 있다.
4. sum === n인 경우를 별도로 처리할 필요가 없다. sum ≤ n인 경우와 동일하게 처리할 수 있다.

## 2-5. 이전 내 풀이와 비교

> [디펜스 게임](https://www.notion.so/7953780f02624e1c8daa1950721a6b6a?pvs=21)

당시, 모든 경우의 수를 순회하는 방법으로 풀이하여, 시간초과에 해당하여 풀지 못하였다.

## 2-6. 다른 사람의 풀이와 비교

```tsx
function solution(n, k, enemy) {
  let lt = 0,
    rt = enemy.length;

  while (lt <= rt) {
    let mid = Math.floor((lt + rt) / 2);
    if (check(n, k, mid, enemy)) lt = mid + 1;
    else rt = mid - 1;
  }

  return lt - 1;
}

const check = (n, k, mid, enemy) => {
  if (mid <= k) return true;

  let t = enemy.slice(0, mid).sort((a, b) => b - a);
  let sum = 0;

  for (let i = k; i < t.length; i++) {
    sum += t[i];
    if (sum > n) return false;
  }
  return true;
};
```

1. 전반적으로 내 풀이와 매우 유사하다.
2. 차이점은
   1. 합산을 구하는 과정에서 이 풀이는 reduce를 사용하지 않고 for문으로 보다 명령적으로 순회했다.
   2. Claude의 조언대로 Meth.floor로 중앙값을 구하고, 종료 조건을 while문 안에 넣었으며 조건은 left ≤ right이다.
