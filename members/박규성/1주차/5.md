# 1. 문제 파악

## 1-1. 주어진 정보

### 인자

1. edges : 그래프의 간선 정보를 담은 2차원 배열
   - [a,b] : a정점에서 b정점으로 향하는 간선이 있다.
   - a,b는 최대 100만

### 리턴값

: [생성한 정점의 번호, 도넛 모양 그래프 수, 막대 모양 그래프 수, 8자 모양 그래프 수]

- 모든 그래프 수의 합은 최소 2

### 전제 조건

1. 그래프 종류 : 도넛 모양, 막대 모양, 8자 모양
   - 도넛 모양 : n개의 정점 + n개의 간선
   - 막대 모양 : n개의 정점 + n-1개의 간선
   - 8자 모양 : 2n+1개의 정점 + 2n+2개의 간선
2. 1개 이상의 정점 + 정점들을 연결하는 단방향 간선
3. 그래프와 무관한 정점을 하나 생성한 뒤, 각 그래프의 정점 하나로 향하는 간선들을 연결

### 유추 결과

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/258711#

# 2. 내 풀이

## 2-1. 풀이

```jsx
function solution(edges) {
  const startEdgeMap = new Map();
  const endEdgeMap = new Map();

  Map.prototype.add = function (key, value) {
    this.set(key, [...(this.get(key) ?? []), value]);
  };

  for (const [startEdge, endEdge] of edges) {
    startEdgeMap.add(startEdge, endEdge);
    endEdgeMap.add(endEdge, startEdge);
  }

  const [mainEdge, graphEdgeList] = [...startEdgeMap.entries()]
    .filter((startEdgeCount) => startEdgeCount[1].length >= 2)
    .filter(([edge]) => !endEdgeMap.has(edge))[0];
  endEdgeMap.delete(mainEdge);

  const dfs = (graphEdge) => {
    const nodeSet = new Set();
    nodeSet.add(graphEdge);
    let newAddedEdgeList = [graphEdge];

    while (1) {
      const beforeNodeSize = nodeSet.size;

      while (newAddedEdgeList.length > 0) {
        const edge = newAddedEdgeList.pop();
        if (startEdgeMap.has(edge)) {
          for (const it of startEdgeMap.get(edge)) {
            if (!nodeSet.has(it)) newAddedEdgeList.push(it);
            nodeSet.add(it);
          }
        }
      }

      const afterNodeSize = nodeSet.size;
      if (afterNodeSize === beforeNodeSize) break;
    }
    nodeSet.delete(mainEdge);
    return [...nodeSet];
  };

  const result = [mainEdge, 0, 0, 0];

  for (const graphEdge of graphEdgeList) {
    const graphEdgeList = dfs(graphEdge);
    let done = false;

    for (const edge of graphEdgeList) {
      if (startEdgeMap.has(edge) && startEdgeMap.get(edge).length > 1) {
        // 8자 모양
        result[3]++;
        done = true;
        break;
      }
      if (!startEdgeMap.has(edge) || !endEdgeMap.has(edge)) {
        // 막대 모양
        result[2]++;
        done = true;
        break;
      }
    }
    if (!done) {
      result[1]++;
    }
  }
  return result;
}
```

- 9번 케이스에서만 시간 초과에 걸린다.

1. startEdgeMap : key는 각 노드, value는 각 노드에서 연결된 노드 배열(출발지)
2. endEdgeMap : key는 각 노드, value는 각 노드로 연결된 노드 배열(도착지)

위 두 개의 Map을 먼저 구했다. 왜냐하면, key-value형태가 기존 2차원 배열보다 접근하기가 더 편할 것이라 생각했다.

그리고 정점 mainEdge을 구해주었다. 이 점의 특징은 출발점(이 노드로부터 출발하는)가 2개 이상이다. 왜냐하면, 문제에서 그래프가 2개 이상이라 주어졌기 떄문이다. 또한, 도착점(이 노드로 도착하는)는 없다. 왜냐하면, 정점은 모든 그래프를 향하기만 하기 때문이다.

```tsx
const [mainEdge, graphEdgeList] = [...startEdgeMap.entries()]
  .filter((startEdgeCount) => startEdgeCount[1].length >= 2)
  .filter(([edge]) => !endEdgeMap.has(edge))[0];
```

이제, 각 그래프의 연결점을 구했으니 이제 연결점을 순회하며 각 그래프를 탐색할 것이다.

```tsx
for (const graphEdge of graphEdgeList) {
  const graphEdgeList = dfs(graphEdge);
  let done = false;

  for (const edge of graphEdgeList) {
    if (startEdgeMap.has(edge) && startEdgeMap.get(edge).length > 1) {
      // 8자 모양
      result[3]++;
      done = true;
      break;
    }
    if (!startEdgeMap.has(edge) || !endEdgeMap.has(edge)) {
      // 막대 모양
      result[2]++;
      done = true;
      break;
    }
  }
  if (!done) {
    result[1]++;
  }
}
```

dfs문을 활용해서 연결점들을 구해주었다.

```tsx
const dfs = (graphEdge) => {
  const nodeSet = new Set();
  nodeSet.add(graphEdge);
  let newAddedEdgeList = [graphEdge];

  while (1) {
    const beforeNodeSize = nodeSet.size;

    while (newAddedEdgeList.length > 0) {
      const edge = newAddedEdgeList.pop();
      if (startEdgeMap.has(edge)) {
        for (const it of startEdgeMap.get(edge)) {
          if (!nodeSet.has(it)) newAddedEdgeList.push(it);
          nodeSet.add(it);
        }
      }
    }

    const afterNodeSize = nodeSet.size;
    if (afterNodeSize === beforeNodeSize) break;
  }
  nodeSet.delete(mainEdge);
  return [...nodeSet];
};
```

## 느낀 점

풀면서 느낀 건데, 너무너무 풀이가 복잡했다.. Map을 사용해서일까, 원래 이렇게 문제가 복잡한 것일까, 내가 풀이를 복잡하게 한 것일까.

## 개선 포인트

1. Map.prototype.add같이 Map프로토타입을 수정하는 것은 좋지 않은 방식이다. 유틸함수를 따로 만드는 것이 더 좋다.
2. result 배열의 인덱스 1,2,3은 각각 다른 구조의 개수를 나타내지만, 이 코드에서 어떤 구조를 나타내는 지 명확하지 않다. 의미 있는 상수를 사용하는 것이 더 좋다.

## 개선 후 코드

```tsx
function solution(edges) {
  const startEdgeMap = new Map();
  const endEdgeMap = new Map();

  function addToMap(map, key, value) {
    if (!map.has(key)) {
      map.set(key, []);
    }
    map.get(key).push(value);
  }

  for (const [startEdge, endEdge] of edges) {
    addToMap(startEdgeMap, startEdge, endEdge);
    addToMap(endEdgeMap, endEdge, startEdge);
  }

  const [mainEdge, graphEdgeList] = [...startEdgeMap.entries()]
    .filter((startEdgeCount) => startEdgeCount[1].length >= 2)
    .filter(([edge]) => !endEdgeMap.has(edge))[0];
  endEdgeMap.delete(mainEdge);

  const dfs = (graphEdge) => {
    const nodeSet = new Set();
    nodeSet.add(graphEdge);
    let newAddedEdgeList = [graphEdge];

    while (1) {
      const beforeNodeSize = nodeSet.size;

      while (newAddedEdgeList.length > 0) {
        const edge = newAddedEdgeList.pop();
        if (startEdgeMap.has(edge)) {
          for (const it of startEdgeMap.get(edge)) {
            if (!nodeSet.has(it)) newAddedEdgeList.push(it);
            nodeSet.add(it);
          }
        }
      }

      const afterNodeSize = nodeSet.size;
      if (afterNodeSize === beforeNodeSize) break;
    }
    nodeSet.delete(mainEdge);
    return [...nodeSet];
  };

  const result = { eightShape: 0, lineShape: 0, donutShape: 0 };

  for (const graphEdge of graphEdgeList) {
    const graphEdgeList = dfs(graphEdge);
    let done = false;

    for (const edge of graphEdgeList) {
      if (startEdgeMap.has(edge) && startEdgeMap.get(edge).length > 1) {
        // 8자 모양
        result.eightShape++;
        done = true;
        break;
      }
      if (!startEdgeMap.has(edge) || !endEdgeMap.has(edge)) {
        // 막대 모양
        result.lineShape++;
        done = true;
        break;
      }
    }
    if (!done) {
      result.donutShape++;
    }
  }
  return [mainEdge, result.donutShape, result.lineShape, result.eightShape];
}
```

## 다른 사람 풀이

```tsx
function solution(edges) {
  const map = {};

  for (const [start, end] of edges) {
    map[start] = map[start] ?? [0, 0];
    map[end] = map[end] ?? [0, 0];
    map[start][0]++;
    map[end][1]++;
  }

  let addedNode = 0;
  let donutCnt = 0;
  let lineCnt = 0;
  let eightCnt = 0;
  for (const [start, [given, received]] of Object.entries(map)) {
    if (given > 1 && received === 0) {
      addedNode = start;
    } else if (given === 0) {
      lineCnt++;
    } else if (given > 1 && received > 1) {
      eightCnt++;
    }
  }

  donutCnt = map[addedNode][0] - lineCnt - eightCnt;

  return [Number(addedNode), donutCnt, lineCnt, eightCnt];
}
```

### 내 풀이와의 차이점

1. Map이 아니라 Object로 관리하였다.
   - Map이 메서드는 직관적이지만, 변경하고, 접근할 때 get,set메서드를 사용해야한다는 점에서 불편하기는 하다. 오히려 가독성을 헤친다. 하지만 객체는, get,set없이 즉시 변경하고 접근할 수 있다. 이런 점에서 둘을 적절하게 사용하는 것이 중요할 듯하다.
2. 각 객체의 값에는 [시작,끝] 배열로 관리하고, 개수로 관리하였다.

   ```tsx
   for (const [start, end] of edges) {
     map[start] = map[start] ?? [0, 0];
     map[end] = map[end] ?? [0, 0];
     map[start][0]++;
     map[end][1]++;
   }
   ```

3. 정점을 먼저 구하지 않고, 특정 조건으로 정점/각 그래프를 구분하였다.

   ```tsx
   for (const [start, [given, received]] of Object.entries(map)) {
     if (given > 1 && received === 0) {
       addedNode = start;
     } else if (given === 0) {
       lineCnt++;
     } else if (given > 1 && received > 1) {
       eightCnt++;
     }
   }
   ```

   1. 정점은, 시작이 2개 이상이고, 도착이 0개인 경우이다.
   2. 1번 조건에 성립하지 않고, 도착이 0개이라면 막대 그래프이다.
   3. 1,2번 조건에 성립하지 않고, 도착이 1개보다 크고 시작도 1개보다 크다면 8자 그래프이다.
   4. 그리고, 정점에서 시작하는 것의 개수에서 막대 그래프와 8자 그래프를 빼면, 도넛 그래프이다.

## 느낀 점

[약 1달 전에 푼 풀이](https://www.notion.so/a19d8e77b34a42479954d5c25a7fc2b9?pvs=21)와 비슷하게 풀어버렸다. 지난 번에 이어서 공통적으로 한 실수는, ‘핵심을 놓친 것’이라 생각한다. 여기서 핵심은, 각 그래프의 특징이다. 당연히 정점을 먼저 구하고, 각 정점으로부터 연결된 그래프를 구하고, 각 그래프 별로 체크해야 한다고 생각했다.

하지만, 굳이 정점을 먼저 구하지 않고, 각 그래프 별 점을 구하지 않아도, 각 그래프/정점의 특징만 파악한다면 충분히 풀 수 있는 문제였다.

1. 정점 : 시작점이 2개 이상 && 도착점이 0개
2. 막대 그래프 : 시작점이 0개 ⇒ 이 점이 막대그래프에 1개라는 것이 핵심이다. 그렇기에 막대그래프의 모든 정점을 체크하지 않아도 된다.
3. 8자 그래프 : 시작점이 2개 이상 & 도착점이 2개 이상 ⇒ 이 점 또한 8자 그래프에 1개이다. 이 점이 곧 중앙점이다.

> 근데 의문이, 정점에서 막대 그래프의 첫 점(시작점 0개), 8자 그래프의 중앙점을 향하면, 이 방식이 안통하지 않을까?
>
> ⇒ 아니다. 정점으로부터의 도착점은 막대그래프의 시작점에 영향을 미치지 않는다. 또한, 8자 그래프에서 1개 초과라는 조건이기 떄문에 1개가 더 늘어나고 무관하다.

## 정리

1. 문제의 핵심인 각 그래프의 조건을 체크하는 것을 대충 넘겨 짚고 풀이를 먼저한 것이 이 문제를 다 풀지 못한 근본적인 원인이었다. 앞으로는 문제의 핵심을 짚는데 더 오랜 시간을 쓰도록 하자.
2. 프로토타입 메서드에 추가하는 것은 좋지 않은 방식이다. 유틸 함수를 따로 만들어서 사용하자.
3. Map을 사용하는 것이 항상 좋은 것은 아니다. 순회가 필요한 경우가 아니라면, 객체 리터럴을 사용하자.
