# 문제 링크

[배달](https://school.programmers.co.kr/learn/courses/30/lessons/12978)

# 1. 내 풀이

다익스트라 알고리즘을 몰라서 처음에 혼자 힘으로 못 풀었습니다.
블로그를 참고해서 이해한 내용을 바탕으로 주석 달았습니다.
오류가 있으면 피드백 부탁드립니다.

[참고 블로그](https://m.blog.naver.com/PostView.naver?blogId=dlaxodud2388&logNo=222634478180&categoryNo=29&proxyReferer=)

```js
function solution(N, road, K) {
  const graph = new Array(N + 1).fill(0).map((v) => []);
  //여기 이렇게 안하고 for 문으로 돌리면 런타임 에러 난다.

  let distance = Array.from({ length: N + 1 }, () => Infinity);
  //거리를 Infinity로 설정한건 작은 값이 있으면 바꾸기 위함.

  let queue = [];
  //a는 이전 마을, b는 다음 마을, c는 거리
  for (let [a, b, c] of road) {
    graph[a].push([b, c]); //이전 마을 입장에서 다음 마을 이름과 사이 거리
    graph[b].push([a, c]); //다음 마을 입장에서 이전 마을 이름과 사이 거리
  }

  queue.push([1, 0]); //1번 마을과 1번 마을까지의 거리는 0
  distance[1] = 0;
  while (queue.length) {
    const [point, cost] = queue.shift();
    for (let i = 0; i < graph[point].length; i++) {
      const next = graph[point][i][0]; //다음 마을 번호
      const nextcost = graph[point][i][1]; //다음 마을까지의 거리
      if (distance[next] > distance[point] + nextcost) {
        //한번도 방문한적이 없는 경우, 아님 더 적은 경우
        distance[next] = distance[point] + nextcost;
        queue.push([next, nextcost]); //일단 push
      }
    }
  }
  distance = distance.filter((v) => v <= K);
  return distance.length;
}
```

## 풀이 방법

다익스트라 알고리즘은 정점끼리의 거리를 비교해서 가장 짧은 것들로 초기화하는 알고리즘이다.
road 배열 안에 [이전 마을, 다음 마을, 사이 거리]가 있는데 이걸 활용해서
해당 마을의 위치에 [다음 마을, 사이 거리]를 지정하면 된다.
방문한적이 없는 마을은 queue에 push하고, 이미 방문한 마을은 기존의 거리와 비교해서 짧은 거리로 초기화한다.

# 2. 느낀 점

# 3. 배운 점
